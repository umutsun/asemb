{
  "name": "Search Result Aggregation",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "search",
        "responseMode": "responseNode",
        "options": {
          "cors": {
            "allowedOrigins": "*"
          }
        }
      },
      "id": "webhook_search",
      "name": "Search Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [250, 300],
      "webhookId": "search-aggregation"
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "query",
              "value": "={{ $json.body.query }}"
            },
            {
              "name": "limit",
              "value": "={{ $json.body.limit || 10 }}"
            },
            {
              "name": "threshold",
              "value": "={{ $json.body.threshold || 0.7 }}"
            }
          ],
          "number": [
            {
              "name": "topK",
              "value": "={{ $json.body.topK || 5 }}"
            }
          ]
        },
        "options": {}
      },
      "id": "extract_params",
      "name": "Extract Parameters",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.2,
      "position": [450, 300]
    },
    {
      "parameters": {
        "operation": "search",
        "query": "={{ $json.query }}",
        "limit": "={{ $json.limit }}",
        "threshold": "={{ $json.threshold }}"
      },
      "id": "vector_search",
      "name": "Vector Search",
      "type": "pgvectorQuery",
      "typeVersion": 1,
      "position": [650, 250],
      "credentials": {
        "pgvectorApi": {
          "id": "1",
          "name": "PgVector DB"
        }
      }
    },
    {
      "parameters": {
        "operation": "hybridSearch",
        "query": "={{ $node['extract_params'].json.query }}",
        "vectorWeight": 0.7,
        "keywordWeight": 0.3,
        "limit": "={{ $node['extract_params'].json.limit }}"
      },
      "id": "hybrid_search",
      "name": "Hybrid Search",
      "type": "pgHybridQuery",
      "typeVersion": 1,
      "position": [650, 350],
      "credentials": {
        "pgvectorApi": {
          "id": "1",
          "name": "PgVector DB"
        }
      }
    },
    {
      "parameters": {
        "operation": "search",
        "searchQuery": "={{ $node['extract_params'].json.query }}",
        "searchMode": "semantic",
        "maxResults": "={{ $node['extract_params'].json.limit }}"
      },
      "id": "asemb_search",
      "name": "ASEMB Search",
      "type": "asembSearch",
      "typeVersion": 1,
      "position": [650, 450],
      "credentials": {
        "aliceSemanticBridgeApi": {
          "id": "1",
          "name": "Alice API"
        }
      }
    },
    {
      "parameters": {
        "mode": "combine",
        "combinationMode": "multiplex",
        "options": {
          "waitForAll": true
        }
      },
      "id": "merge_results",
      "name": "Merge Results",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [850, 350]
    },
    {
      "parameters": {
        "jsCode": "// Aggregate and rank results from multiple sources\nconst vectorResults = $input.item.json.vector || [];\nconst hybridResults = $input.item.json.hybrid || [];\nconst asembResults = $input.item.json.asemb || [];\n\n// Create a map to aggregate scores\nconst resultMap = new Map();\n\n// Process vector search results\nvectorResults.forEach(result => {\n  const key = result.id || result.document_id;\n  if (!resultMap.has(key)) {\n    resultMap.set(key, {\n      ...result,\n      sources: ['vector'],\n      scores: { vector: result.similarity || result.score || 0 },\n      aggregateScore: 0\n    });\n  } else {\n    const existing = resultMap.get(key);\n    existing.sources.push('vector');\n    existing.scores.vector = result.similarity || result.score || 0;\n  }\n});\n\n// Process hybrid search results\nhybridResults.forEach(result => {\n  const key = result.id || result.document_id;\n  if (!resultMap.has(key)) {\n    resultMap.set(key, {\n      ...result,\n      sources: ['hybrid'],\n      scores: { hybrid: result.score || 0 },\n      aggregateScore: 0\n    });\n  } else {\n    const existing = resultMap.get(key);\n    existing.sources.push('hybrid');\n    existing.scores.hybrid = result.score || 0;\n  }\n});\n\n// Process ASEMB search results\nasembResults.forEach(result => {\n  const key = result.id || result.document_id;\n  if (!resultMap.has(key)) {\n    resultMap.set(key, {\n      ...result,\n      sources: ['asemb'],\n      scores: { asemb: result.relevance || result.score || 0 },\n      aggregateScore: 0\n    });\n  } else {\n    const existing = resultMap.get(key);\n    existing.sources.push('asemb');\n    existing.scores.asemb = result.relevance || result.score || 0;\n  }\n});\n\n// Calculate aggregate scores with weighted averaging\nresultMap.forEach(result => {\n  const weights = {\n    vector: 0.4,\n    hybrid: 0.35,\n    asemb: 0.25\n  };\n  \n  let totalScore = 0;\n  let totalWeight = 0;\n  \n  Object.keys(result.scores).forEach(source => {\n    totalScore += result.scores[source] * weights[source];\n    totalWeight += weights[source];\n  });\n  \n  result.aggregateScore = totalWeight > 0 ? totalScore / totalWeight : 0;\n});\n\n// Sort by aggregate score and limit results\nconst aggregatedResults = Array.from(resultMap.values())\n  .sort((a, b) => b.aggregateScore - a.aggregateScore)\n  .slice(0, parseInt($node['extract_params'].json.topK));\n\nreturn aggregatedResults;"
      },
      "id": "aggregate_rankings",
      "name": "Aggregate Rankings",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1050, 350]
    },
    {
      "parameters": {
        "operation": "rerank",
        "documents": "={{ $json }}",
        "query": "={{ $node['extract_params'].json.query }}",
        "model": "rerank-english-v2.0",
        "topN": "={{ $node['extract_params'].json.topK }}"
      },
      "id": "rerank_results",
      "name": "Rerank Results",
      "type": "aliceSemanticBridgeEnhanced",
      "typeVersion": 1,
      "position": [1250, 350],
      "credentials": {
        "aliceSemanticBridgeApi": {
          "id": "1",
          "name": "Alice API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Format final results for response\nconst results = $input.all();\n\nconst formattedResults = results.map((item, index) => ({\n  rank: index + 1,\n  id: item.json.id || item.json.document_id,\n  title: item.json.title || item.json.metadata?.title || 'Untitled',\n  content: item.json.content || item.json.text || '',\n  snippet: (item.json.content || item.json.text || '').substring(0, 200) + '...',\n  url: item.json.url || item.json.metadata?.url || '',\n  score: item.json.aggregateScore || item.json.score,\n  sources: item.json.sources || [],\n  metadata: item.json.metadata || {},\n  highlights: item.json.highlights || []\n}));\n\nreturn {\n  query: $node['extract_params'].json.query,\n  totalResults: formattedResults.length,\n  results: formattedResults,\n  searchMetadata: {\n    timestamp: new Date().toISOString(),\n    processingTime: Date.now() - $workflow.startedAt,\n    searchMethods: ['vector', 'hybrid', 'semantic'],\n    threshold: $node['extract_params'].json.threshold,\n    limit: $node['extract_params'].json.limit\n  }\n};"
      },
      "id": "format_response",
      "name": "Format Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1450, 350]
    },
    {
      "parameters": {
        "key": "search:{{ $json.query }}:{{ $now.toISOString().split('T')[0] }}",
        "value": "={{ JSON.stringify($json) }}",
        "ttl": 3600
      },
      "id": "cache_results",
      "name": "Cache Results",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 2,
      "position": [1650, 350],
      "credentials": {
        "redis": {
          "id": "1",
          "name": "Redis Cache"
        }
      }
    },
    {
      "parameters": {
        "operation": "logActivity",
        "activityType": "search_aggregation",
        "details": "={{ JSON.stringify({ query: $json.query, resultsCount: $json.totalResults, processingTime: $json.searchMetadata.processingTime }) }}"
      },
      "id": "log_search",
      "name": "Log Search",
      "type": "dashboard",
      "typeVersion": 1,
      "position": [1850, 350]
    },
    {
      "parameters": {
        "respondWith": "allIncomingItems",
        "options": {}
      },
      "id": "respond_webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2050, 350]
    },
    {
      "parameters": {
        "key": "search:{{ $json.query }}:{{ $now.toISOString().split('T')[0] }}"
      },
      "id": "check_cache",
      "name": "Check Cache",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 2,
      "position": [450, 150],
      "credentials": {
        "redis": {
          "id": "1",
          "name": "Redis Cache"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.value ? true : false }}",
              "value2": true
            }
          ]
        }
      },
      "id": "cache_hit_check",
      "name": "Cache Hit Check",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [650, 150]
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "response",
              "value": "={{ JSON.parse($json.value) }}"
            }
          ]
        },
        "options": {
          "dotNotation": false
        }
      },
      "id": "parse_cached",
      "name": "Parse Cached",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.2,
      "position": [850, 100]
    }
  ],
  "connections": {
    "Search Webhook": {
      "main": [
        [
          {
            "node": "Check Cache",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Cache": {
      "main": [
        [
          {
            "node": "Cache Hit Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cache Hit Check": {
      "main": [
        [
          {
            "node": "Parse Cached",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extract Parameters",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Cached": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Parameters": {
      "main": [
        [
          {
            "node": "Vector Search",
            "type": "main",
            "index": 0
          },
          {
            "node": "Hybrid Search",
            "type": "main",
            "index": 0
          },
          {
            "node": "ASEMB Search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Vector Search": {
      "main": [
        [
          {
            "node": "Merge Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Hybrid Search": {
      "main": [
        [
          {
            "node": "Merge Results",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "ASEMB Search": {
      "main": [
        [
          {
            "node": "Merge Results",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Merge Results": {
      "main": [
        [
          {
            "node": "Aggregate Rankings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Rankings": {
      "main": [
        [
          {
            "node": "Rerank Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Rerank Results": {
      "main": [
        [
          {
            "node": "Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Response": {
      "main": [
        [
          {
            "node": "Cache Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cache Results": {
      "main": [
        [
          {
            "node": "Log Search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log Search": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "saveDataSuccessExecution": "all",
    "saveExecutionProgress": true,
    "saveManualExecutions": true,
    "executionTimeout": 60,
    "errorWorkflow": "error-handler"
  },
  "tags": ["template", "search", "aggregation", "pgvector", "hybrid", "cache"],
  "pinData": {},
  "versionId": "1.0.0"
}